# 关于整数二分陷入死循环的问题（可用二分模板）

## 1. 区间[l, r]被分为[l, mid]和[mid + 1, r]时使用

```c
int binary_search1(int l, int r){
    while(l <= r){
        int mid = (l + r) >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    return 1;
}
```

## 2. 区间[l, r]被分为[l, mid - 1]和[mid, r]时使用

```c
int binary_search2(int l, int r){
    while(l <= r){
        int mid = (l + r + 1) >> 1;
        if(check(mid)) r = mid - 1;
        else l = mid;
    }
    return 1;
}
```

## 3. 如何理解上述两个问题的不同？

典型例子：“数的范围”

假如有这样一组数：1, 1, 2, 3, 3, 4

要求：确定数字3在这组数中的下标范围

这就带来了确定==左边界==和==右边界==的问题

分别思考：

对于左边界，就是要找到==>=3的最小下标==，因此确定==“性质”==为大于等于3，对应的要更新r为mid，因为此时==mid有可能是答案==（最重要的点），那么对应的l就更新为mid + 1了

对于右边界，就是要找到==<=3的最大下标==，因此确定==“性质”==为小于等于3，对应的要更新l为mid，因为此时==mid有可能是答案==（最重要的点），那么对应的r就更新为mid - 1了

## 4. 如何记忆到底使用(l + r) >> 1还是(l + r + 1)>>1？

只需记住一种情况：当l = r - 1并且更新方式为l = mid, mid = (l + r) >> 1 时，会陷入死循环，注意避免这种情况即可

























